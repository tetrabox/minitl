/*
 * generated by Xtext 2.27.0
 */
package org.tetrabox.example.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.tetrabox.example.minitl.BinaryExpression;
import org.tetrabox.example.minitl.Binding;
import org.tetrabox.example.minitl.FieldAccessValue;
import org.tetrabox.example.minitl.Metamodel;
import org.tetrabox.example.minitl.MinitlPackage;
import org.tetrabox.example.minitl.ObjectTemplate;
import org.tetrabox.example.minitl.ObjectTemplateValue;
import org.tetrabox.example.minitl.Rule;
import org.tetrabox.example.minitl.StringValue;
import org.tetrabox.example.minitl.Transformation;
import org.tetrabox.example.services.MinitlGrammarAccess;

@SuppressWarnings("all")
public class MinitlSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MinitlGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MinitlPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MinitlPackage.BINARY_EXPRESSION:
				sequence_MaybeBinary(context, (BinaryExpression) semanticObject); 
				return; 
			case MinitlPackage.BINDING:
				sequence_Binding(context, (Binding) semanticObject); 
				return; 
			case MinitlPackage.FIELD_ACCESS_VALUE:
				sequence_MaybeFieldAccessValue(context, (FieldAccessValue) semanticObject); 
				return; 
			case MinitlPackage.METAMODEL:
				sequence_Metamodel(context, (Metamodel) semanticObject); 
				return; 
			case MinitlPackage.OBJECT_TEMPLATE:
				sequence_ObjectTemplate(context, (ObjectTemplate) semanticObject); 
				return; 
			case MinitlPackage.OBJECT_TEMPLATE_VALUE:
				sequence_ObjectTemplateValue(context, (ObjectTemplateValue) semanticObject); 
				return; 
			case MinitlPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case MinitlPackage.STRING_VALUE:
				sequence_StringValue(context, (StringValue) semanticObject); 
				return; 
			case MinitlPackage.TRANSFORMATION:
				sequence_Transformation(context, (Transformation) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Binding returns Binding
	 *
	 * Constraint:
	 *     (feature=[EStructuralFeature|ID] value=Value)
	 * </pre>
	 */
	protected void sequence_Binding(ISerializationContext context, Binding semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinitlPackage.Literals.BINDING__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinitlPackage.Literals.BINDING__FEATURE));
			if (transientValues.isValueTransient(semanticObject, MinitlPackage.Literals.BINDING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinitlPackage.Literals.BINDING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBindingAccess().getFeatureEStructuralFeatureIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MinitlPackage.Literals.BINDING__FEATURE, false));
		feeder.accept(grammarAccess.getBindingAccess().getValueValueParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns BinaryExpression
	 *     MaybeBinary returns BinaryExpression
	 *     MaybeBinary.BinaryExpression_1_0 returns BinaryExpression
	 *     MaybeFieldAccessValue returns BinaryExpression
	 *     MaybeFieldAccessValue.FieldAccessValue_1_0 returns BinaryExpression
	 *     Primary returns BinaryExpression
	 *
	 * Constraint:
	 *     (expressions+=MaybeBinary_BinaryExpression_1_0 operator=Operator expressions+=MaybeFieldAccessValue)
	 * </pre>
	 */
	protected void sequence_MaybeBinary(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns FieldAccessValue
	 *     MaybeBinary returns FieldAccessValue
	 *     MaybeBinary.BinaryExpression_1_0 returns FieldAccessValue
	 *     MaybeFieldAccessValue returns FieldAccessValue
	 *     MaybeFieldAccessValue.FieldAccessValue_1_0 returns FieldAccessValue
	 *     Primary returns FieldAccessValue
	 *
	 * Constraint:
	 *     (object=MaybeFieldAccessValue_FieldAccessValue_1_0 feature=[EStructuralFeature|ID])
	 * </pre>
	 */
	protected void sequence_MaybeFieldAccessValue(ISerializationContext context, FieldAccessValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinitlPackage.Literals.FIELD_ACCESS_VALUE__OBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinitlPackage.Literals.FIELD_ACCESS_VALUE__OBJECT));
			if (transientValues.isValueTransient(semanticObject, MinitlPackage.Literals.FIELD_ACCESS_VALUE__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinitlPackage.Literals.FIELD_ACCESS_VALUE__FEATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMaybeFieldAccessValueAccess().getFieldAccessValueObjectAction_1_0(), semanticObject.getObject());
		feeder.accept(grammarAccess.getMaybeFieldAccessValueAccess().getFeatureEStructuralFeatureIDTerminalRuleCall_1_2_0_1(), semanticObject.eGet(MinitlPackage.Literals.FIELD_ACCESS_VALUE__FEATURE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InputMetamodel returns Metamodel
	 *     Metamodel returns Metamodel
	 *
	 * Constraint:
	 *     (packages+=[EPackage|FQN] packages+=[EPackage|FQN]*)
	 * </pre>
	 */
	protected void sequence_Metamodel(ISerializationContext context, Metamodel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns ObjectTemplateValue
	 *     MaybeBinary returns ObjectTemplateValue
	 *     MaybeBinary.BinaryExpression_1_0 returns ObjectTemplateValue
	 *     MaybeFieldAccessValue returns ObjectTemplateValue
	 *     MaybeFieldAccessValue.FieldAccessValue_1_0 returns ObjectTemplateValue
	 *     Primary returns ObjectTemplateValue
	 *     ObjectTemplateValue returns ObjectTemplateValue
	 *
	 * Constraint:
	 *     objecttemplate=[ObjectTemplate|ID]
	 * </pre>
	 */
	protected void sequence_ObjectTemplateValue(ISerializationContext context, ObjectTemplateValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinitlPackage.Literals.OBJECT_TEMPLATE_VALUE__OBJECTTEMPLATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinitlPackage.Literals.OBJECT_TEMPLATE_VALUE__OBJECTTEMPLATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjectTemplateValueAccess().getObjecttemplateObjectTemplateIDTerminalRuleCall_0_1(), semanticObject.eGet(MinitlPackage.Literals.OBJECT_TEMPLATE_VALUE__OBJECTTEMPLATE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ObjectTemplate returns ObjectTemplate
	 *
	 * Constraint:
	 *     (name=ID type=[EClass|FQN] (bindings+=Binding bindings+=Binding*)?)
	 * </pre>
	 */
	protected void sequence_ObjectTemplate(ISerializationContext context, ObjectTemplate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Rule returns Rule
	 *
	 * Constraint:
	 *     (name=ID objectTemplates+=ObjectTemplate objectTemplates+=ObjectTemplate)
	 * </pre>
	 */
	protected void sequence_Rule(ISerializationContext context, Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns StringValue
	 *     MaybeBinary returns StringValue
	 *     MaybeBinary.BinaryExpression_1_0 returns StringValue
	 *     MaybeFieldAccessValue returns StringValue
	 *     MaybeFieldAccessValue.FieldAccessValue_1_0 returns StringValue
	 *     Primary returns StringValue
	 *     StringValue returns StringValue
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_StringValue(ISerializationContext context, StringValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinitlPackage.Literals.STRING_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinitlPackage.Literals.STRING_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringValueAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Transformation returns Transformation
	 *
	 * Constraint:
	 *     (name=ID inputMetamodel=InputMetamodel? outputMetamodel=Metamodel? (rules+=Rule rules+=Rule*)?)
	 * </pre>
	 */
	protected void sequence_Transformation(ISerializationContext context, Transformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
